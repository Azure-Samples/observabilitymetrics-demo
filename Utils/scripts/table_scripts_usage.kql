//create raw tables

.create-merge table Cognitive_Svc_Usage_Raw (metrics: dynamic) with (folder = "Raw")

.create-merge table Cognitive_Svc_Latency_Raw (metrics: dynamic) with (folder = "Raw")

.create-merge table Cognitive_Svc_RateLimit_Raw (metrics: dynamic) with (folder = "Raw")
// Create ingestion mapping

.create-or-alter table Cognitive_Svc_Usage_Raw ingestion json mapping 'RawMetricsMapping' '[{"Column":"metrics","Properties":{"path":"$"}}]'

.create-or-alter table Cognitive_Svc_Latency_Raw ingestion json mapping 'RawMetricsMapping' '[{"Column":"metrics","Properties":{"path":"$"}}]'

.create-or-alter table Cognitive_Svc_RateLimit_Raw ingestion json mapping 'RawMetricsMapping' '[{"Column":"metrics","Properties":{"path":"$"}}]'

//create adx tables

.create-merge table Cognitive_Svc_Usage (['date']: datetime, ['id']: string, generatedtokens: decimal, processedprompttokens: decimal,inferencetokens: decimal,finetunedtraininghours: decimal,apiname: string, modeldeploymentname: string, featurename: string, subscriptionId: guid, location: string, name: string)

.create-merge table Cognitive_Svc_Latency (['date']: datetime, ['id']: string, latency: decimal, apiname:string, operationname: string,  ratelimitkey: string, subscriptionId: guid, location: string, name: string)

.create-merge table Cognitive_Svc_RateLimit (['date']: datetime, ['id']: string, ratelimit: decimal, ratelimitkey: string, subscriptionId: guid, location: string, name: string)

//create functions

.create-or-alter function  Parse_Cognitive_Svc_Usage() {
let apiname1=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'GeneratedTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'apiname'
    | extend apiname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct  timestamp = todatetime(data.timeStamp), id = tostring(id), generatedtokens = todecimal(data.total), apiname = tostring(apiname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let apiname2=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'ProcessedPromptTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'apiname'
    | extend apiname = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct  timestamp = todatetime(data.timeStamp), id = tostring(id), processedprompttokens = todecimal(data.total), apiname = tostring(apiname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let modeldeploymentname1=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'GeneratedTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'modeldeploymentname'
    | extend modeldeploymentname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), generatedtokens = todecimal(data.total), modeldeploymentname=tostring(modeldeploymentname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let modeldeploymentname2=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'ProcessedPromptTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'modeldeploymentname'
    | extend modeldeploymentname = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), processedprompttokens = todecimal(data.total), modeldeploymentname=tostring(modeldeploymentname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let featurename1=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'GeneratedTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'featurename'
    | extend featurename = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), generatedtokens = todecimal(data.total), featurename=tostring(featurename),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let featurename2=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'ProcessedPromptTokens'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'featurename'
    | extend featurename = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), processedprompttokens = todecimal(data.total), featurename=tostring(featurename),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let apiname3=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'TokenTransaction'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'apiname'
    | extend apiname = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct  timestamp = todatetime(data.timeStamp), id = tostring(id), inferencetokens = todecimal(data.total), apiname = tostring(apiname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let modeldeploymentname3=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'TokenTransaction'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'modeldeploymentname'
    | extend modeldeploymentname = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), inferencetokens = todecimal(data.total), modeldeploymentname=tostring(modeldeploymentname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let featurename3=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'TokenTransaction'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'featurename'
    | extend featurename = metadatavalues.value
    | mv-expand data = timeseries.data
    | where  data.total>0
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), inferencetokens = todecimal(data.total), featurename=tostring(featurename),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let apiname4=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'FineTunedTrainingHours'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'apiname'
    | extend apiname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct  timestamp = todatetime(data.timeStamp), id = tostring(id), finetunedtraininghours = todecimal(data.total), apiname = tostring(apiname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let modeldeploymentname4=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'FineTunedTrainingHours'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'modeldeploymentname'
    | extend modeldeploymentname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), finetunedtraininghours = todecimal(data.total), modeldeploymentname=tostring(modeldeploymentname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let featurename4=Cognitive_Svc_Usage_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'FineTunedTrainingHours'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'featurename'
    | extend featurename = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), finetunedtraininghours = todecimal(data.total), featurename=tostring(featurename),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let t1=apiname2
| join kind=leftouter apiname1 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter apiname3 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter apiname4 on $left.id==$right.id and $left.timestamp==$right.timestamp;
let t2= modeldeploymentname2
| join kind=leftouter modeldeploymentname1 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter modeldeploymentname3 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter modeldeploymentname4 on $left.id==$right.id and $left.timestamp==$right.timestamp;
let t3= featurename2
| join kind=leftouter featurename1 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter featurename3 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind=leftouter featurename4 on $left.id==$right.id and $left.timestamp==$right.timestamp;
t1
| join kind = inner t2 on $left.id==$right.id and $left.timestamp==$right.timestamp
| join kind = inner t3 on $left.id==$right.id and $left.timestamp==$right.timestamp
| distinct  timestamp = timestamp, id = tostring(id), generatedtokens=generatedtokens, processedprompttokens = processedprompttokens, inferencetokens =inferencetokens, finetunedtraininghours=finetunedtraininghours,apiname = tostring(apiname), modeldeploymentname = tostring(modeldeploymentname),featurename=tostring(featurename),
 subscriptionId = subscriptionId, location = location, name = tostring(name)
 | where inferencetokens == (generatedtokens +processedprompttokens)
}

.create-or-alter function  Parse_Cognitive_Svc_Latency() {
let ratelimitkey=Cognitive_Svc_Latency_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'Latency'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'ratelimitkey'
    | extend ratelimitkey = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct  timestamp = todatetime(data.timeStamp), id = tostring(id), latency = todecimal(data.average), ratelimitkey = tostring(ratelimitkey),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let region=Cognitive_Svc_Latency_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'Latency'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'region'
    | extend region = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), latency = todecimal(data.average), region=tostring(region),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let apiname=Cognitive_Svc_Latency_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'Latency'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'apiname'
    | extend apiname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), latency = todecimal(data.average), apiname=tostring(apiname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let operationname=Cognitive_Svc_Latency_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'Latency'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'operationname'
    | extend operationname = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), latency = todecimal(data.average), operationname=tostring(operationname),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
(
ratelimitkey
| join kind = leftouter region on $left.timestamp == $right.timestamp and $left.id == $right.id
| join kind = leftouter apiname on $left.timestamp == $right.timestamp and $left.id == $right.id
| join kind = leftouter operationname on $left.timestamp == $right.timestamp and $left.id == $right.id
| where apiname has "Azure OpenAI API"
| distinct  timestamp, id, latency, apiname, operationname, ratelimitkey, subscriptionId, location, name
)
}

.create-or-alter function  Parse_Cognitive_Svc_RateLimit() {
let ratelimitkey=Cognitive_Svc_RateLimit_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'Ratelimit'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'RatelimitKey'
    | extend ratelimitkey = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), ratelimit = todecimal(data.total), ratelimitkey = tostring(ratelimitkey),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
let region=Cognitive_Svc_RateLimit_Raw
    | mv-expand values = metrics.values
    | extend id = tostring(values.resourceid)
    | extend subscriptionId = split(id, '/')[2]
    | extend name = split(id, '/')[-1]
    | extend region = tostring(values.resourceregion)
    | mv-expand value = values.value
    | where tostring(value.name.value) == 'RateLimit'
    | mv-expand timeseries = value.timeseries
    | mv-expand metadatavalues = timeseries.metadatavalues
    | where metadatavalues.name.value == 'region'
    | extend region = metadatavalues.value
    | mv-expand data = timeseries.data
    | distinct timestamp = todatetime(data.timeStamp), id = tostring(id), ratelimit = todecimal(data.total), region=tostring(region),
     location = tostring(region), subscriptionId = toguid(subscriptionId), name = tostring(name);
     (ratelimitkey | join kind = leftouter region on $left.timestamp == $right.timestamp and $left.id == $right.id)
    | distinct timestamp, id, ratelimit, ratelimitkey, subscriptionId, location, name
 }

// Update results table policies

.alter table Cognitive_Svc_Usage policy update @'[{"Source": "Cognitive_Svc_Usage_Raw", "Query": "Parse_Cognitive_Svc_Usage()", "IsEnabled": "True", "IsTransactional": true}]'

.alter table Cognitive_Svc_RateLimit policy update @'[{"Source": "Cognitive_Svc_RateLimit_Raw", "Query": "Parse_Cognitive_Svc_RateLimit()", "IsEnabled": "True", "IsTransactional": true}]'

.alter table Cognitive_Svc_Latency policy update @'[{"Source": "Cognitive_Svc_Latency_Raw", "Query": "Parse_Cognitive_Svc_Latency()", "IsEnabled": "True", "IsTransactional": true}]'


// Adding zero retention policies on Raw tables

.alter-merge table Cognitive_Svc_Usage_Raw policy retention softdelete = 0s

.alter-merge table Cognitive_Svc_RateLimit_Raw policy retention softdelete = 0s

.alter-merge table Cognitive_Svc_Latency_Raw policy retention softdelete = 0s
